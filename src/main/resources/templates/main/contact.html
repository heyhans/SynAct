<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head th:replace="~{main/fragments/head :: head('SynAct Contact')}"></head>

<body>
    <!-- 헤더 -->
    <div th:replace="~{main/fragments/menu :: menu}"></div>

    <main class="bg-circle-between">

        <!-- 1. 폼 섹션 -->
        <section class="contact-form">
            <div class="cont-inner">
                <div class="wrap-title">
                    <h2 class="tit" data-aos="fade-up">Get in Touch</h2>
                    <p class="subtxt" data-aos="fade-up" data-aos-delay="100">Ready to Transform Your Business?</p>
                </div>

<!--                <div class="wrap-info" data-aos="fade-up" data-aos-delay="300">-->
<!--                    <div class="info-item mail">-->
<!--                        <a class="item-text" href="mailto:hello@synact.ai">hello@synact.ai</a>-->
<!--                    </div>-->
<!--                    <div class="info-item tel">-->
<!--                        <a class="item-text" href="tel:+82-2-1234-5678">+82-2-1234-5678</a>-->
<!--                    </div>-->
<!--                    <div class="info-item map">-->
<!--                        <span class="item-text">Seoul, South Korea</span>-->
<!--                    </div>-->
<!--                </div>-->

                <div class="wrap-form" data-aos="fade-up" data-aos-delay="500">
                    <form th:action="@{/web/contact}" th:object="${contactForm}" method="post">
                        <!-- CSRF (needed if Spring Security CSRF is enabled) -->
                        <input type="hidden" th:if="${_csrf != null}" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
                        <input type="hidden" name="recaptchaToken" id="recaptchaToken">

                        <div class="box-desc">Please fill in the form below to get in touch with us.</div>

                        <div class="form-inner">

                            <!-- Row 1: First / Last name -->
                            <div class="field-wrap field-2col">
                                <label class="field">
                                    <input type="text"
                                           class="form-input"
                                           th:field="*{firstName}"
                                           placeholder="First name"
                                           autocomplete="given-name">
                                    <small class="field-error" data-for="firstName"></small>
                                </label>

                                <label class="field">
                                    <input type="text"
                                           class="form-input"
                                           th:field="*{lastName}"
                                           placeholder="Last name"
                                           autocomplete="family-name">
                                    <small class="field-error" data-for="lastName"></small>
                                </label>
                            </div>

                            <!-- Row 2: Email / Phone -->
                            <div class="field-wrap field-2col">
                                <label class="field">
                                    <input type="text"
                                           class="form-input"
                                           th:field="*{email}"
                                           placeholder="Email address"
                                           autocomplete="email">
                                    <small class="field-error" data-for="email"></small>
                                </label>

                                <label class="field">
                                    <input type="text"
                                           class="form-input"
                                           th:field="*{phone}"
                                           placeholder="Phone number (e.g. +821012345678)"
                                           autocomplete="tel">
                                    <small class="field-error" data-for="phone"></small>
                                </label>
                            </div>

                            <!-- Row 3: Company (full width) -->
                            <div class="field-wrap">
                                <label class="field field-full">
                                    <input type="text"
                                           class="form-input"
                                           th:field="*{company}"
                                           placeholder="Company"
                                           autocomplete="organization">
                                    <small class="field-error" data-for="company"></small>
                                </label>
                            </div>

                            <!-- Row 4: Message (full width) -->
                            <div class="field-wrap">
                                <label class="field field-full">
                                    <textarea class="form-input"
                                              th:field="*{message}"
                                              rows="4"
                                              placeholder="Message"></textarea>
                                    <small class="field-error" data-for="message"></small>
                                </label>
                            </div>

                            <!-- Row 5: Consent (not stored in DB; used to block submission) -->
                            <div class="field-wrap">
                                <label class="consent">
                                    <input type="checkbox" id="consent" name="consent">
                                    <span>
                                        I’ve read and agree with
                                        <a href="#none">Terms of Service</a>
                                        and
                                        <a href="#none">Privacy Policy</a>
                                    </span>
                                </label>
                                <small class="field-error" data-for="consent"></small>
                            </div>

                            <div class="box-btn">
                                <button type="submit" class="btn-submit" id="contactSubmit">Send Message</button>
                            </div>

                        </div>
                    </form>
                </div>

            </div>
        </section>


        <!-- 2. 공통 하단 섹션 -->
        <section class="contact-bottom common-bottom">
            <div class="cont-inner">
                <h2 class="title" data-aos="fade-up">Why Choose SynAct.ai?</h2>
                <div class="wrap-desc" data-aos="fade-up" data-aos-delay="100">
                    <p class="txt" data-aos="fade-up" data-aos-delay="200">AI that ships—fast, reliable, measurable.</p>
                    <p class="txt" data-aos="fade-up" data-aos-delay="400">Security-first delivery with clear data boundaries.</p>
                    <p class="txt" data-aos="fade-up" data-aos-delay="600">Automation that cuts time, errors, and cost.</p>
                    <p class="txt" data-aos="fade-up" data-aos-delay="800">A partner team that stays after launch.</p>
                </div>
            </div>
        </section>
    </main>


    <script src="/js/common.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Thymeleaf removes th:* in the final HTML, so don't query th:object.
            const form =
                document.querySelector('form[action*="/web/contact"]') ||
                document.querySelector('form');

            if (!form) return;

            // Fields (th:field will render "name" like firstName, lastName, etc.)
            const firstName = form.querySelector('[name$="firstName"]');
            const lastName  = form.querySelector('[name$="lastName"]');
            const email     = form.querySelector('[name$="email"]');
            const phone     = form.querySelector('[name$="phone"]');
            const company   = form.querySelector('[name$="company"]');
            const message   = form.querySelector('[name$="message"]');
            const consent   = form.querySelector('#consent');
            const submitBtn = form.querySelector('#contactSubmit, button[type="submit"]');

            // Regex rules (match your DTO intent)
            const NAME_RE  = /^[A-Za-z]+(?:[ '-][A-Za-z]+)*$/;
            const EMAIL_RE = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            const PHONE_RE = /^\+[1-9]\d{7,14}$/;

            // Track interaction so we don't show errors on initial load
            const touched = {
                firstName: false,
                lastName: false,
                email: false,
                phone: false,
                company: false,
                message: false,
                consent: false,
            };
            let submitAttempted = false;

            function getErrorEl(key) {
                // Use your existing placeholders: <small class="field-error" data-for="...">
                let el = form.querySelector(`.field-error[data-for="${key}"]`);
                if (!el) {
                    el = document.createElement('small');
                    el.className = 'field-error';
                    el.dataset.for = key;
                    // fallback append (shouldn't happen if your HTML already has the <small>)
                    form.appendChild(el);
                }
                return el;
            }

            function setInvalid(inputEl, errorEl, msg, show) {
                if (inputEl) inputEl.classList.add('is-invalid');
                if (!errorEl) return;
                if (show) {
                    errorEl.textContent = msg || '';
                    errorEl.style.display = msg ? 'block' : 'none';
                } else {
                    // do not display message before touch/submit
                    errorEl.textContent = '';
                    errorEl.style.display = 'none';
                }
            }

            function setValid(inputEl, errorEl) {
                if (inputEl) inputEl.classList.remove('is-invalid');
                if (errorEl) {
                    errorEl.textContent = '';
                    errorEl.style.display = 'none';
                }
            }

            function shouldShow(key) {
                return submitAttempted || touched[key] === true;
            }

            // Each validator returns boolean. It only shows messages when shouldShow(key) is true.
            function validateFirstName() {
                const key = 'firstName';
                const v = (firstName?.value || '').trim();
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (!v) { setInvalid(firstName, err, 'First name is required.', show); return false; }
                if (!NAME_RE.test(v)) { setInvalid(firstName, err, "English letters only. Use space, - or '.", show); return false; }
                setValid(firstName, err); return true;
            }

            function validateLastName() {
                const key = 'lastName';
                const v = (lastName?.value || '').trim();
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (!v) { setInvalid(lastName, err, 'Last name is required.', show); return false; }
                if (!NAME_RE.test(v)) { setInvalid(lastName, err, "English letters only. Use space, - or '.", show); return false; }
                setValid(lastName, err); return true;
            }

            function validateEmail() {
                const key = 'email';
                const v = (email?.value || '').trim();
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (!v) { setInvalid(email, err, 'Email is required.', show); return false; }
                if (!EMAIL_RE.test(v)) { setInvalid(email, err, 'Please enter a valid email address.', show); return false; }
                setValid(email, err); return true;
            }

            function validatePhone() {
                const key = 'phone';
                const v = (phone?.value || '').trim();
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (!v) { setInvalid(phone, err, 'Phone number is required.', show); return false; }
                if (!PHONE_RE.test(v)) { setInvalid(phone, err, 'Use E.164 format, e.g. +821012345678.', show); return false; }
                setValid(phone, err); return true;
            }

            function validateCompany() {
                const key = 'company';
                const v = (company?.value || '').trim();
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (v.length > 255) { setInvalid(company, err, 'Company must be 255 characters or less.', show); return false; }
                setValid(company, err); return true;
            }

            function validateMessage() {
                const key = 'message';
                const v = (message?.value || '').trim();
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (!v) { setInvalid(message, err, 'Message is required.', show); return false; }
                if (v.length > 2000) { setInvalid(message, err, 'Message must be 2000 characters or less.', show); return false; }
                setValid(message, err); return true;
            }

            function validateConsent() {
                const key = 'consent';
                const err = getErrorEl(key);
                const show = shouldShow(key);

                if (!consent?.checked) {
                    // no inputEl to highlight here; show message only after touch/submit
                    if (show) { err.textContent = 'You must agree to proceed.'; err.style.display = 'block'; }
                    else { err.textContent = ''; err.style.display = 'none'; }
                    return false;
                }
                err.textContent = '';
                err.style.display = 'none';
                return true;
            }

            function updateButtonState() {
                const ok =
                    validateFirstName() &&
                    validateLastName() &&
                    validateEmail() &&
                    validatePhone() &&
                    validateCompany() &&
                    validateMessage() &&
                    validateConsent();

                if (submitBtn) submitBtn.disabled = !ok;
                return ok;
            }

            // Mark touched and validate on interaction
            function bindLive(el, key, validator) {
                if (!el) return;
                el.addEventListener('input', () => { touched[key] = true; validator(); updateButtonState(); });
                el.addEventListener('blur',  () => { touched[key] = true; validator(); updateButtonState(); });
            }

            bindLive(firstName, 'firstName', validateFirstName);
            bindLive(lastName,  'lastName',  validateLastName);
            bindLive(email,     'email',     validateEmail);
            bindLive(phone,     'phone',     validatePhone);
            bindLive(company,   'company',   validateCompany);
            bindLive(message,   'message',   validateMessage);

            if (consent) {
                consent.addEventListener('change', () => {
                    touched.consent = true;
                    validateConsent();
                    updateButtonState();
                });
            }

            // On submit: show everything
            form.addEventListener('submit', (e) => {
                submitAttempted = true;
                // Force display rules now that submit is attempted
                const ok = updateButtonState();
                if (!ok) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // INITIALIZE:
            // 1) Hide all client-side error placeholders
            ['firstName','lastName','email','phone','company','message','consent'].forEach(k => {
                const el = getErrorEl(k);
                el.textContent = '';
                el.style.display = 'none';
            });
            // 2) Don't show errors; just disable/enable button based on current values
            updateButtonState();
        });
    </script>

    <script th:inline="javascript">
        const RECAPTCHA_SITE_KEY = /*[[${@environment.getProperty('google.recaptcha.site-key')}]]*/ "";

        // v3 loader
    </script>
    <script th:src="'https://www.google.com/recaptcha/api.js?render=' + ${@environment.getProperty('google.recaptcha.site-key')}" async defer></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const form = document.querySelector('form');
            if (!form) return;

            const tokenInput = document.getElementById('recaptchaToken');

            // Call v3 and refresh token
            async function refreshToken() {
                if (!window.grecaptcha || !RECAPTCHA_SITE_KEY) return;
                return new Promise((resolve) => {
                    grecaptcha.ready(() => {
                        grecaptcha.execute(RECAPTCHA_SITE_KEY, { action: 'contact_submit' })
                            .then((token) => {
                                tokenInput.value = token;
                                resolve(token);
                            })
                            .catch(() => resolve(null));
                    });
                });
            }

            // Get token on load
            refreshToken();

            // Refresh token before submit (important: token expires quickly)
            form.addEventListener('submit', async (e) => {
                // If token missing, prevent submit, fetch, then submit once
                if (!tokenInput.value) {
                    e.preventDefault();
                    await refreshToken();
                    if (tokenInput.value) form.submit();
                }
            });

            // Optional: refresh token when user interacts (safer)
            ['focusin', 'input', 'change'].forEach(evt => {
                form.addEventListener(evt, () => {
                    // don’t spam: just ensure there is *some* token
                    if (!tokenInput.value) refreshToken();
                }, { passive: true });
            });
        });
    </script>

</body>
</html>